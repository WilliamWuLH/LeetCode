## 5728. 最少侧跳次数

给你一个长度为 `n` 的 **3 跑道道路** ，它总共包含 `n + 1` 个 **点** ，编号为 `0` 到 `n` 。一只青蛙从 `0` 号点第二条跑道 **出发** ，它想要跳到点 `n` 处。然而道路上可能有一些障碍。

给你一个长度为 `n + 1` 的数组 `obstacles` ，其中 `obstacles[i]` （**取值范围从 0 到 3**）表示在点 `i` 处的 `obstacles[i]` 跑道上有一个障碍。如果 `obstacles[i] == 0` ，那么点 `i` 处没有障碍。任何一个点的三条跑道中 **最多有一个** 障碍。

- 比方说，如果 `obstacles[2] == 1` ，那么说明在点 2 处跑道 1 有障碍。

这只青蛙从点 `i` 跳到点 `i + 1` 且跑道不变的前提是点 `i + 1` 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 **同一个** 点处 **侧跳** 到 **另外一条** 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。

- 比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。

这只青蛙从点 0 处跑道 `2` 出发，并想到达点 `n` 处的 **任一跑道** ，请你返回 **最少侧跳次数** 。

**注意**：点 `0` 处和点 `n` 处的任一跑道都不会有障碍。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex1.png)

```
输入：obstacles = [0,1,2,3,0]
输出：2 
解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。
注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex2.png)

```
输入：obstacles = [0,1,1,3,3,0]
输出：0
解释：跑道 2 没有任何障碍，所以不需要任何侧跳。
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex3.png)

```
输入：obstacles = [0,2,1,0,3,0]
输出：2
解释：最优方案如上图所示。总共有 2 次侧跳。
```

**提示：**

- `obstacles.length == n + 1`
- `1 <= n <= 5 * 105`
- `0 <= obstacles[i] <= 3`
- `obstacles[0] == obstacles[n] == 0`

#### 贪心 + 跑道判断：

​		**贪心**：在每一次必须更换跑道的时候，选择可以走最远的那条跑道。

​		**跑道判断**：

- 更换跑道时，如果当前的点和前面一个的点都有障碍，那么更换的跑道不能是当前点的障碍所在的跑道和前一个点的障碍所在的跑道。所以此时我们只有一条跑道可以选择更换。
- 在更换跑道之后，如果有两条跑道可以选择，我们需要判断更换的跑道是不是可以走最远的那条跑道。
  - 如果更换跑道后，首先遇到了没有选择的另一条跑道的障碍，那么我们现在所选择的跑道就是可以走最远的那条跑道。
  - 如果更换跑道后，首先遇到了我们选择的这条跑道的障碍，那么我们选择错误，应该选择另一条跑道，所以我们应该修正跑道，更换新的跑道，但是使用的是之前更换跑道的消耗，不产生新的消耗。

**详见代码注释**：

```c++
class Solution {
public:
    int minSideJumps(vector<int>& ob) {
        // pos：当前跑道，pre：之前的跑道，ch：需要判断是不是可以走最远的那条跑道，lasti：前一个点的障碍所在跑道
        int pos = 2, pre = 2, ch = 0, lasti = 0;
        int ans = 0;
        // 遍历每个点
        for(auto &i : ob){
            // 需要判断是不是可以走最远的那条跑道：当前点有障碍，并且障碍在没有选择的另一条跑道上
            // 更换跑道的选择正确
            if(ch == 1 && i != 0 && i != pos && i != pre)
                // 无需再判断是不是可以走最远的那条跑道
                ch = 0;
            // 当前跑道遇到障碍
            if(i == pos){
                // 需要更换跑道
                if(ch == 0){
                    // 更换次数加一
                    ans++;
                    ch = 1;
                    pre = pos;
                    // 只有一条跑道可以选择，所以无需判断是不是可以走最远的那条跑道
                    if(lasti != 0)
                        ch = 0;
                    // 选择更换到哪一条跑道上
                    pos = pos+1 > 3 ? 1 : pos+1;
                    // 选择的跑道和前一个点的障碍跑道重合了，重新选择跑道
                    if(pos == lasti)
                        pos = pos+1 > 3 ? 1 : pos+1;
                }
                // 需要判断是不是可以走最远的那条跑道：当前点有障碍，并且障碍在我们选择的这条跑道
                // 更换跑道的选择错误
                else{
                    // 无需再判断是不是可以走最远的那条跑道
                    ch = 0;
                    // 修正跑道：更换另一条跑道，使用之前更换的那次消耗
                    pos = pos+1 > 3 ? 1 : pos+1;
                }
            }
            // 记录前一个点的障碍
            lasti = i;
        }
        return  ans;
    }
};
```

